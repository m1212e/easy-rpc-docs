import{S as ot,i as nt,s as lt,U as Ve,v as ut,w as ct,x as dt,V as pt,W as ht,f as ft,t as mt,y as yt,X as rt,k as s,q as d,a as f,l as r,m as o,h as t,r as p,c as m,n as a,b as l,D as i,E as vt}from"../../../../chunks/index-5459d0c8.js";import{P as bt}from"../../../../chunks/Page-f7e08464.js";function wt(F){let u,h,v,N,c,y,$,Z,b,w,L,me,ee,_,ye,O,q,ve,be,te,g,x,z,we,ae,H,_e,ie,E,S,M,ge,se,J,xe,re,k,A,U,Ee,oe,V,Se,ne,P,T,X,ke,le,I,Ae,K,B,Pe,Te,ue,j,C,Q,Ie,ce,D,je,de,R,W,Y,Ce,pe,G,Re;return{c(){u=s("h1"),h=s("a"),v=s("span"),N=d("Features"),c=f(),y=s("p"),$=d("A short list of the most important easy-rpc features."),Z=f(),b=s("h2"),w=s("a"),L=s("span"),me=d("Easy to learn syntax"),ee=f(),_=s("p"),ye=d("The easy-rpc syntax is very easy to learn. If you\u2019ve ever written TypeScript, JavaScript, Java, C#, Go, Rust or really any modern programming language you\u2019ll quickly get used to it. The syntax will be explained in detail in the "),O=s("strong"),q=s("a"),ve=d("syntax section"),be=d(" of the documentation."),te=f(),g=s("h2"),x=s("a"),z=s("span"),we=d("Single source of truth"),ae=f(),H=s("p"),_e=d("easy-rpc really shines when configured to share sources across projects. This can be done inside its configuration and is commonly done once when setting up a project. When sharing a single source of truth, mismatches between caller and reciever of a request are easily detected while devoloping or building the project. This is a difference to other protocols, where the structure of requests is documented manually e.g. via OpenAPI or similar tools. With easy-rpc there is no documentation which can get out of sync."),ie=f(),E=s("h2"),S=s("a"),M=s("span"),ge=d("Language server and VSCode addon"),se=f(),J=s("p"),xe=d("The language server and VSCode addon provide help while developing with easy-rpc. Most important: They update the generated clients while you type your .erpc files. This ensures you never have to run the easy-rpc transpiler manually and provides a smooth developer experience. Just type out your definition and instantly start using it."),re=f(),k=s("h2"),A=s("a"),U=s("span"),Ee=d("Fast transpiler"),oe=f(),V=s("p"),Se=d("The easy-rpc transpiler is written in Rust and is optimized for concurrency and performance. It can handle hundreds of .erpc files in huge projects without a significant increase in build time. It\u2019s well suited for automated build pipelines and CI/CD workflows."),ne=f(),P=s("h2"),T=s("a"),X=s("span"),ke=d("Real time communication via WebSockets"),le=f(),I=s("p"),Ae=d("easy-rpc uses roles to define entities which can communicate inside your application. Since easy-rpc is meant for Web Applications, it uses WebSockets to allow for endpoints defined inside the browser, callable from a server. All the socket handling is done under the hood. This is how easy WebSockets can be. Read more about Roles and Endpoints in "),K=s("strong"),B=s("a"),Pe=d("their chapter"),Te=d("."),ue=f(),j=s("h1"),C=s("a"),Q=s("span"),Ie=d("Philosophy"),ce=f(),D=s("p"),je=d("easy-rpc is meant to be simple and easy to use. Its goal is not to provide a solution for every problem that comes with web and web communication, but to make it easy, safe and accessible to write APIs for the web. Its highest priority is to provide a nice and clean developer experience and to make things enjoyable."),de=f(),R=s("h1"),W=s("a"),Y=s("span"),Ce=d("Languages"),pe=f(),G=s("p"),Re=d("easy-rpc is currently generating TypeScript code meant for usage with Node.js. Since generating the actual Clients from the .erpc files is a very complex task which takes a lot of time, it might take a while until other languages will be supported. But is is planned to bring easy-rpc to all the languages commonly used for web development."),this.h()},l(e){u=r(e,"H1",{id:!0});var n=o(u);h=r(n,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Be=o(h);v=r(Be,"SPAN",{class:!0}),o(v).forEach(t),Be.forEach(t),N=p(n,"Features"),n.forEach(t),c=m(e),y=r(e,"P",{});var De=o(y);$=p(De,"A short list of the most important easy-rpc features."),De.forEach(t),Z=m(e),b=r(e,"H2",{id:!0});var We=o(b);w=r(We,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ge=o(w);L=r(Ge,"SPAN",{class:!0}),o(L).forEach(t),Ge.forEach(t),me=p(We,"Easy to learn syntax"),We.forEach(t),ee=m(e),_=r(e,"P",{});var he=o(_);ye=p(he,"The easy-rpc syntax is very easy to learn. If you\u2019ve ever written TypeScript, JavaScript, Java, C#, Go, Rust or really any modern programming language you\u2019ll quickly get used to it. The syntax will be explained in detail in the "),O=r(he,"STRONG",{});var Le=o(O);q=r(Le,"A",{href:!0});var Oe=o(q);ve=p(Oe,"syntax section"),Oe.forEach(t),Le.forEach(t),be=p(he," of the documentation."),he.forEach(t),te=m(e),g=r(e,"H2",{id:!0});var Ne=o(g);x=r(Ne,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ze=o(x);z=r(ze,"SPAN",{class:!0}),o(z).forEach(t),ze.forEach(t),we=p(Ne,"Single source of truth"),Ne.forEach(t),ae=m(e),H=r(e,"P",{});var Me=o(H);_e=p(Me,"easy-rpc really shines when configured to share sources across projects. This can be done inside its configuration and is commonly done once when setting up a project. When sharing a single source of truth, mismatches between caller and reciever of a request are easily detected while devoloping or building the project. This is a difference to other protocols, where the structure of requests is documented manually e.g. via OpenAPI or similar tools. With easy-rpc there is no documentation which can get out of sync."),Me.forEach(t),ie=m(e),E=r(e,"H2",{id:!0});var Fe=o(E);S=r(Fe,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ue=o(S);M=r(Ue,"SPAN",{class:!0}),o(M).forEach(t),Ue.forEach(t),ge=p(Fe,"Language server and VSCode addon"),Fe.forEach(t),se=m(e),J=r(e,"P",{});var Xe=o(J);xe=p(Xe,"The language server and VSCode addon provide help while developing with easy-rpc. Most important: They update the generated clients while you type your .erpc files. This ensures you never have to run the easy-rpc transpiler manually and provides a smooth developer experience. Just type out your definition and instantly start using it."),Xe.forEach(t),re=m(e),k=r(e,"H2",{id:!0});var $e=o(k);A=r($e,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ke=o(A);U=r(Ke,"SPAN",{class:!0}),o(U).forEach(t),Ke.forEach(t),Ee=p($e,"Fast transpiler"),$e.forEach(t),oe=m(e),V=r(e,"P",{});var Qe=o(V);Se=p(Qe,"The easy-rpc transpiler is written in Rust and is optimized for concurrency and performance. It can handle hundreds of .erpc files in huge projects without a significant increase in build time. It\u2019s well suited for automated build pipelines and CI/CD workflows."),Qe.forEach(t),ne=m(e),P=r(e,"H2",{id:!0});var qe=o(P);T=r(qe,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ye=o(T);X=r(Ye,"SPAN",{class:!0}),o(X).forEach(t),Ye.forEach(t),ke=p(qe,"Real time communication via WebSockets"),qe.forEach(t),le=m(e),I=r(e,"P",{});var fe=o(I);Ae=p(fe,"easy-rpc uses roles to define entities which can communicate inside your application. Since easy-rpc is meant for Web Applications, it uses WebSockets to allow for endpoints defined inside the browser, callable from a server. All the socket handling is done under the hood. This is how easy WebSockets can be. Read more about Roles and Endpoints in "),K=r(fe,"STRONG",{});var Ze=o(K);B=r(Ze,"A",{href:!0});var et=o(B);Pe=p(et,"their chapter"),et.forEach(t),Ze.forEach(t),Te=p(fe,"."),fe.forEach(t),ue=m(e),j=r(e,"H1",{id:!0});var He=o(j);C=r(He,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var tt=o(C);Q=r(tt,"SPAN",{class:!0}),o(Q).forEach(t),tt.forEach(t),Ie=p(He,"Philosophy"),He.forEach(t),ce=m(e),D=r(e,"P",{});var at=o(D);je=p(at,"easy-rpc is meant to be simple and easy to use. Its goal is not to provide a solution for every problem that comes with web and web communication, but to make it easy, safe and accessible to write APIs for the web. Its highest priority is to provide a nice and clean developer experience and to make things enjoyable."),at.forEach(t),de=m(e),R=r(e,"H1",{id:!0});var Je=o(R);W=r(Je,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var it=o(W);Y=r(it,"SPAN",{class:!0}),o(Y).forEach(t),it.forEach(t),Ce=p(Je,"Languages"),Je.forEach(t),pe=m(e),G=r(e,"P",{});var st=o(G);Re=p(st,"easy-rpc is currently generating TypeScript code meant for usage with Node.js. Since generating the actual Clients from the .erpc files is a very complex task which takes a lot of time, it might take a while until other languages will be supported. But is is planned to bring easy-rpc to all the languages commonly used for web development."),st.forEach(t),this.h()},h(){a(v,"class","icon icon-link"),a(h,"aria-hidden","true"),a(h,"tabindex","-1"),a(h,"href","#features"),a(u,"id","features"),a(L,"class","icon icon-link"),a(w,"aria-hidden","true"),a(w,"tabindex","-1"),a(w,"href","#easy-to-learn-syntax"),a(b,"id","easy-to-learn-syntax"),a(q,"href","/easy-rpc-docs/3%F0%9F%96%8B%EF%B8%8F%20Syntax/"),a(z,"class","icon icon-link"),a(x,"aria-hidden","true"),a(x,"tabindex","-1"),a(x,"href","#single-source-of-truth"),a(g,"id","single-source-of-truth"),a(M,"class","icon icon-link"),a(S,"aria-hidden","true"),a(S,"tabindex","-1"),a(S,"href","#language-server-and-vscode-addon"),a(E,"id","language-server-and-vscode-addon"),a(U,"class","icon icon-link"),a(A,"aria-hidden","true"),a(A,"tabindex","-1"),a(A,"href","#fast-transpiler"),a(k,"id","fast-transpiler"),a(X,"class","icon icon-link"),a(T,"aria-hidden","true"),a(T,"tabindex","-1"),a(T,"href","#real-time-communication-via-websockets"),a(P,"id","real-time-communication-via-websockets"),a(B,"href","/easy-rpc-docs/2%F0%9F%8E%AD%20Roles%20and%20Endpoints/"),a(Q,"class","icon icon-link"),a(C,"aria-hidden","true"),a(C,"tabindex","-1"),a(C,"href","#philosophy"),a(j,"id","philosophy"),a(Y,"class","icon icon-link"),a(W,"aria-hidden","true"),a(W,"tabindex","-1"),a(W,"href","#languages"),a(R,"id","languages")},m(e,n){l(e,u,n),i(u,h),i(h,v),i(u,N),l(e,c,n),l(e,y,n),i(y,$),l(e,Z,n),l(e,b,n),i(b,w),i(w,L),i(b,me),l(e,ee,n),l(e,_,n),i(_,ye),i(_,O),i(O,q),i(q,ve),i(_,be),l(e,te,n),l(e,g,n),i(g,x),i(x,z),i(g,we),l(e,ae,n),l(e,H,n),i(H,_e),l(e,ie,n),l(e,E,n),i(E,S),i(S,M),i(E,ge),l(e,se,n),l(e,J,n),i(J,xe),l(e,re,n),l(e,k,n),i(k,A),i(A,U),i(k,Ee),l(e,oe,n),l(e,V,n),i(V,Se),l(e,ne,n),l(e,P,n),i(P,T),i(T,X),i(P,ke),l(e,le,n),l(e,I,n),i(I,Ae),i(I,K),i(K,B),i(B,Pe),i(I,Te),l(e,ue,n),l(e,j,n),i(j,C),i(C,Q),i(j,Ie),l(e,ce,n),l(e,D,n),i(D,je),l(e,de,n),l(e,R,n),i(R,W),i(W,Y),i(R,Ce),l(e,pe,n),l(e,G,n),i(G,Re)},p:vt,d(e){e&&t(u),e&&t(c),e&&t(y),e&&t(Z),e&&t(b),e&&t(ee),e&&t(_),e&&t(te),e&&t(g),e&&t(ae),e&&t(H),e&&t(ie),e&&t(E),e&&t(se),e&&t(J),e&&t(re),e&&t(k),e&&t(oe),e&&t(V),e&&t(ne),e&&t(P),e&&t(le),e&&t(I),e&&t(ue),e&&t(j),e&&t(ce),e&&t(D),e&&t(de),e&&t(R),e&&t(pe),e&&t(G)}}}function _t(F){let u,h;const v=[F[0]];let N={$$slots:{default:[wt]},$$scope:{ctx:F}};for(let c=0;c<v.length;c+=1)N=Ve(N,v[c]);return u=new bt({props:N}),{c(){ut(u.$$.fragment)},l(c){ct(u.$$.fragment,c)},m(c,y){dt(u,c,y),h=!0},p(c,[y]){const $=y&1?pt(v,[ht(c[0])]):{};y&2&&($.$$scope={dirty:y,ctx:c}),u.$set($)},i(c){h||(ft(u.$$.fragment,c),h=!0)},o(c){mt(u.$$.fragment,c),h=!1},d(c){yt(u,c)}}}function gt(F,u,h){return F.$$set=v=>{h(0,u=Ve(Ve({},u),rt(v)))},u=rt(u),[u]}class St extends ot{constructor(u){super(),nt(this,u,gt,_t,lt,{})}}export{St as default};
