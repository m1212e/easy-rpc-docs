import{S as vt,i as bt,s as wt,R as Ke,v as _t,w as gt,x as Et,T as xt,U as kt,f as St,t as At,y as Pt,V as yt,k as i,q as c,a as h,l as r,m as o,h as t,r as d,c as f,n as a,b as l,D as s,E as Tt}from"../../../../chunks/index-f7d5173d.js";import{P as It}from"../../../../chunks/Page-a5ffcd41.js";function Rt(H){let u,m,v,$,p,y,q,se,b,w,M,ge,ie,_,Ee,U,J,xe,ke,re,g,E,K,Se,oe,V,Ae,ne,x,k,Q,Pe,le,B,Te,ue,S,A,X,Ie,ce,D,Re,de,P,T,Y,je,pe,I,Ce,Z,G,Ne,We,he,R,j,ee,Fe,fe,L,$e,me,C,N,te,He,ye,O,qe,ve,W,F,ae,Je,be,z,Ve;return{c(){u=i("h1"),m=i("a"),v=i("span"),$=c("Features"),p=h(),y=i("p"),q=c("A short list of the most important easy-rpc features."),se=h(),b=i("h2"),w=i("a"),M=i("span"),ge=c("Easy to learn syntax"),ie=h(),_=i("p"),Ee=c("The easy-rpc syntax is very easy to learn. If you\u2019ve ever written TypeScript, JavaScript, Java, C#, Go, Rust or really any modern programming language you\u2019ll quickly get used to it. The syntax will be explained in detail in the "),U=i("strong"),J=i("a"),xe=c("syntax section"),ke=c(" of the documentation."),re=h(),g=i("h2"),E=i("a"),K=i("span"),Se=c("Single source of truth"),oe=h(),V=i("p"),Ae=c("easy-rpc really shines when configured to share sources across projects. This can be done inside its configuration and is commonly done once when setting up a project. When sharing a single source of truth, mismatches between caller and reciever of a request are easily detected while devoloping or building the project. This is a difference to other protocols, where the structure of requests is documented manually e.g. via OpenAPI or similar tools. With easy-rpc there is no documentation which can get out of sync."),ne=h(),x=i("h2"),k=i("a"),Q=i("span"),Pe=c("Language server and VSCode addon"),le=h(),B=i("p"),Te=c("The language server and VSCode addon provide help while developing with easy-rpc. Most important: They update the generated clients while you type your .erpc files. This ensures you never have to run the easy-rpc transpiler manually and provides a smooth developer experience. Just type out your definition and instantly start using it."),ue=h(),S=i("h2"),A=i("a"),X=i("span"),Ie=c("Fast transpiler"),ce=h(),D=i("p"),Re=c("The easy-rpc transpiler is written in Rust and is optimized for concurrency and performance. It can handle hundreds of .erpc files in huge projects without a significant increase in build time. It\u2019s well suited for automated build pipelines and CI/CD workflows."),de=h(),P=i("h2"),T=i("a"),Y=i("span"),je=c("Real time communication via WebSockets"),pe=h(),I=i("p"),Ce=c("easy-rpc uses roles to define entities which can communicate inside your application. Since easy-rpc is meant for Web Applications, it uses WebSockets to allow for endpoints defined inside the browser, callable from a server. All the socket handling is done under the hood. This is how easy WebSockets can be. Read more about Roles and Endpoints in "),Z=i("strong"),G=i("a"),Ne=c("their chapter"),We=c("."),he=h(),R=i("h2"),j=i("a"),ee=i("span"),Fe=c("Remote sources"),fe=h(),L=i("p"),$e=c("easy-rpc allows for importing remote sources from source control providers like github or custom hosted websites. This allows for easy usage of APIs provided by others."),me=h(),C=i("h1"),N=i("a"),te=i("span"),He=c("Philosophy"),ye=h(),O=i("p"),qe=c("easy-rpc is meant to be simple and easy to use. Its goal is not to provide a solution for every problem that comes with web and web communication, but to make it easy, safe and accessible to write APIs for the web. Its highest priority is to provide a nice and clean developer experience and to make things enjoyable."),ve=h(),W=i("h1"),F=i("a"),ae=i("span"),Je=c("Languages"),be=h(),z=i("p"),Ve=c("easy-rpc is currently generating TypeScript code meant for usage with Node.js. Since generating the actual Clients from the .erpc files is a very complex task which takes a lot of time, it might take a while until other languages will be supported. But is is planned to bring easy-rpc to all the languages commonly used for web development."),this.h()},l(e){u=r(e,"H1",{id:!0});var n=o(u);m=r(n,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Qe=o(m);v=r(Qe,"SPAN",{class:!0}),o(v).forEach(t),Qe.forEach(t),$=d(n,"Features"),n.forEach(t),p=f(e),y=r(e,"P",{});var Xe=o(y);q=d(Xe,"A short list of the most important easy-rpc features."),Xe.forEach(t),se=f(e),b=r(e,"H2",{id:!0});var Be=o(b);w=r(Be,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ye=o(w);M=r(Ye,"SPAN",{class:!0}),o(M).forEach(t),Ye.forEach(t),ge=d(Be,"Easy to learn syntax"),Be.forEach(t),ie=f(e),_=r(e,"P",{});var we=o(_);Ee=d(we,"The easy-rpc syntax is very easy to learn. If you\u2019ve ever written TypeScript, JavaScript, Java, C#, Go, Rust or really any modern programming language you\u2019ll quickly get used to it. The syntax will be explained in detail in the "),U=r(we,"STRONG",{});var Ze=o(U);J=r(Ze,"A",{href:!0});var et=o(J);xe=d(et,"syntax section"),et.forEach(t),Ze.forEach(t),ke=d(we," of the documentation."),we.forEach(t),re=f(e),g=r(e,"H2",{id:!0});var De=o(g);E=r(De,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var tt=o(E);K=r(tt,"SPAN",{class:!0}),o(K).forEach(t),tt.forEach(t),Se=d(De,"Single source of truth"),De.forEach(t),oe=f(e),V=r(e,"P",{});var at=o(V);Ae=d(at,"easy-rpc really shines when configured to share sources across projects. This can be done inside its configuration and is commonly done once when setting up a project. When sharing a single source of truth, mismatches between caller and reciever of a request are easily detected while devoloping or building the project. This is a difference to other protocols, where the structure of requests is documented manually e.g. via OpenAPI or similar tools. With easy-rpc there is no documentation which can get out of sync."),at.forEach(t),ne=f(e),x=r(e,"H2",{id:!0});var Ge=o(x);k=r(Ge,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var st=o(k);Q=r(st,"SPAN",{class:!0}),o(Q).forEach(t),st.forEach(t),Pe=d(Ge,"Language server and VSCode addon"),Ge.forEach(t),le=f(e),B=r(e,"P",{});var it=o(B);Te=d(it,"The language server and VSCode addon provide help while developing with easy-rpc. Most important: They update the generated clients while you type your .erpc files. This ensures you never have to run the easy-rpc transpiler manually and provides a smooth developer experience. Just type out your definition and instantly start using it."),it.forEach(t),ue=f(e),S=r(e,"H2",{id:!0});var Le=o(S);A=r(Le,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var rt=o(A);X=r(rt,"SPAN",{class:!0}),o(X).forEach(t),rt.forEach(t),Ie=d(Le,"Fast transpiler"),Le.forEach(t),ce=f(e),D=r(e,"P",{});var ot=o(D);Re=d(ot,"The easy-rpc transpiler is written in Rust and is optimized for concurrency and performance. It can handle hundreds of .erpc files in huge projects without a significant increase in build time. It\u2019s well suited for automated build pipelines and CI/CD workflows."),ot.forEach(t),de=f(e),P=r(e,"H2",{id:!0});var Oe=o(P);T=r(Oe,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var nt=o(T);Y=r(nt,"SPAN",{class:!0}),o(Y).forEach(t),nt.forEach(t),je=d(Oe,"Real time communication via WebSockets"),Oe.forEach(t),pe=f(e),I=r(e,"P",{});var _e=o(I);Ce=d(_e,"easy-rpc uses roles to define entities which can communicate inside your application. Since easy-rpc is meant for Web Applications, it uses WebSockets to allow for endpoints defined inside the browser, callable from a server. All the socket handling is done under the hood. This is how easy WebSockets can be. Read more about Roles and Endpoints in "),Z=r(_e,"STRONG",{});var lt=o(Z);G=r(lt,"A",{href:!0});var ut=o(G);Ne=d(ut,"their chapter"),ut.forEach(t),lt.forEach(t),We=d(_e,"."),_e.forEach(t),he=f(e),R=r(e,"H2",{id:!0});var ze=o(R);j=r(ze,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ct=o(j);ee=r(ct,"SPAN",{class:!0}),o(ee).forEach(t),ct.forEach(t),Fe=d(ze,"Remote sources"),ze.forEach(t),fe=f(e),L=r(e,"P",{});var dt=o(L);$e=d(dt,"easy-rpc allows for importing remote sources from source control providers like github or custom hosted websites. This allows for easy usage of APIs provided by others."),dt.forEach(t),me=f(e),C=r(e,"H1",{id:!0});var Me=o(C);N=r(Me,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var pt=o(N);te=r(pt,"SPAN",{class:!0}),o(te).forEach(t),pt.forEach(t),He=d(Me,"Philosophy"),Me.forEach(t),ye=f(e),O=r(e,"P",{});var ht=o(O);qe=d(ht,"easy-rpc is meant to be simple and easy to use. Its goal is not to provide a solution for every problem that comes with web and web communication, but to make it easy, safe and accessible to write APIs for the web. Its highest priority is to provide a nice and clean developer experience and to make things enjoyable."),ht.forEach(t),ve=f(e),W=r(e,"H1",{id:!0});var Ue=o(W);F=r(Ue,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ft=o(F);ae=r(ft,"SPAN",{class:!0}),o(ae).forEach(t),ft.forEach(t),Je=d(Ue,"Languages"),Ue.forEach(t),be=f(e),z=r(e,"P",{});var mt=o(z);Ve=d(mt,"easy-rpc is currently generating TypeScript code meant for usage with Node.js. Since generating the actual Clients from the .erpc files is a very complex task which takes a lot of time, it might take a while until other languages will be supported. But is is planned to bring easy-rpc to all the languages commonly used for web development."),mt.forEach(t),this.h()},h(){a(v,"class","icon icon-link"),a(m,"aria-hidden","true"),a(m,"tabindex","-1"),a(m,"href","#features"),a(u,"id","features"),a(M,"class","icon icon-link"),a(w,"aria-hidden","true"),a(w,"tabindex","-1"),a(w,"href","#easy-to-learn-syntax"),a(b,"id","easy-to-learn-syntax"),a(J,"href","/easy-rpc-docs/3%F0%9F%96%8B%EF%B8%8F%20Syntax/"),a(K,"class","icon icon-link"),a(E,"aria-hidden","true"),a(E,"tabindex","-1"),a(E,"href","#single-source-of-truth"),a(g,"id","single-source-of-truth"),a(Q,"class","icon icon-link"),a(k,"aria-hidden","true"),a(k,"tabindex","-1"),a(k,"href","#language-server-and-vscode-addon"),a(x,"id","language-server-and-vscode-addon"),a(X,"class","icon icon-link"),a(A,"aria-hidden","true"),a(A,"tabindex","-1"),a(A,"href","#fast-transpiler"),a(S,"id","fast-transpiler"),a(Y,"class","icon icon-link"),a(T,"aria-hidden","true"),a(T,"tabindex","-1"),a(T,"href","#real-time-communication-via-websockets"),a(P,"id","real-time-communication-via-websockets"),a(G,"href","/easy-rpc-docs/2%F0%9F%8E%AD%20Roles%20and%20Endpoints/"),a(ee,"class","icon icon-link"),a(j,"aria-hidden","true"),a(j,"tabindex","-1"),a(j,"href","#remote-sources"),a(R,"id","remote-sources"),a(te,"class","icon icon-link"),a(N,"aria-hidden","true"),a(N,"tabindex","-1"),a(N,"href","#philosophy"),a(C,"id","philosophy"),a(ae,"class","icon icon-link"),a(F,"aria-hidden","true"),a(F,"tabindex","-1"),a(F,"href","#languages"),a(W,"id","languages")},m(e,n){l(e,u,n),s(u,m),s(m,v),s(u,$),l(e,p,n),l(e,y,n),s(y,q),l(e,se,n),l(e,b,n),s(b,w),s(w,M),s(b,ge),l(e,ie,n),l(e,_,n),s(_,Ee),s(_,U),s(U,J),s(J,xe),s(_,ke),l(e,re,n),l(e,g,n),s(g,E),s(E,K),s(g,Se),l(e,oe,n),l(e,V,n),s(V,Ae),l(e,ne,n),l(e,x,n),s(x,k),s(k,Q),s(x,Pe),l(e,le,n),l(e,B,n),s(B,Te),l(e,ue,n),l(e,S,n),s(S,A),s(A,X),s(S,Ie),l(e,ce,n),l(e,D,n),s(D,Re),l(e,de,n),l(e,P,n),s(P,T),s(T,Y),s(P,je),l(e,pe,n),l(e,I,n),s(I,Ce),s(I,Z),s(Z,G),s(G,Ne),s(I,We),l(e,he,n),l(e,R,n),s(R,j),s(j,ee),s(R,Fe),l(e,fe,n),l(e,L,n),s(L,$e),l(e,me,n),l(e,C,n),s(C,N),s(N,te),s(C,He),l(e,ye,n),l(e,O,n),s(O,qe),l(e,ve,n),l(e,W,n),s(W,F),s(F,ae),s(W,Je),l(e,be,n),l(e,z,n),s(z,Ve)},p:Tt,d(e){e&&t(u),e&&t(p),e&&t(y),e&&t(se),e&&t(b),e&&t(ie),e&&t(_),e&&t(re),e&&t(g),e&&t(oe),e&&t(V),e&&t(ne),e&&t(x),e&&t(le),e&&t(B),e&&t(ue),e&&t(S),e&&t(ce),e&&t(D),e&&t(de),e&&t(P),e&&t(pe),e&&t(I),e&&t(he),e&&t(R),e&&t(fe),e&&t(L),e&&t(me),e&&t(C),e&&t(ye),e&&t(O),e&&t(ve),e&&t(W),e&&t(be),e&&t(z)}}}function jt(H){let u,m;const v=[H[0]];let $={$$slots:{default:[Rt]},$$scope:{ctx:H}};for(let p=0;p<v.length;p+=1)$=Ke($,v[p]);return u=new It({props:$}),{c(){_t(u.$$.fragment)},l(p){gt(u.$$.fragment,p)},m(p,y){Et(u,p,y),m=!0},p(p,[y]){const q=y&1?xt(v,[kt(p[0])]):{};y&2&&(q.$$scope={dirty:y,ctx:p}),u.$set(q)},i(p){m||(St(u.$$.fragment,p),m=!0)},o(p){At(u.$$.fragment,p),m=!1},d(p){Pt(u,p)}}}function Ct(H,u,m){return H.$$set=v=>{m(0,u=Ke(Ke({},u),yt(v)))},u=yt(u),[u]}class Ft extends vt{constructor(u){super(),bt(this,u,Ct,jt,wt,{})}}export{Ft as default};
